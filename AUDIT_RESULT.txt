Issue: 1
Location: const API_KEY = "sk_live_9f8as7df9as8df";
Description: Hard-coded API secret in source; use environment variables or a secrets manager.

Issue: 2
Location: if (userRole == 'admin') {
Description: Loose equality in JavaScript can coerce types; use strict equality (===) to avoid unintended truthiness and potential privilege escalation.

Issue: 3
Location: cursor.execute("SELECT * FROM users WHERE email = '" + email + "'")
Description: Potential SQL injection via string concatenation; use parameterized queries or prepared statements.

Issue: 4
Location: return n * factorial(n - 1)
Description: Recursive call without a base-case guard; can cause infinite recursion or stack overflow for n <= 0.

Issue: 5
Location: let last = arr[arr.length];
Description: Off-by-one error; the last valid index is arr.length - 1, this reads undefined.

Issue: 6
Location: for (let i = 0; i <= items.length; i++) total += items[i].price;
Description: Off-by-one error: when i equals items.length, items[i] is undefined and accessing .price throws; use i < items.length.

Issue: 7
Location: const sql = `SELECT * FROM users WHERE username = '${req.query.user}' AND pass = '${req.query.pass}'`;
Description: SQL injection vulnerability due to unparameterized string interpolation; use prepared statements/parameterized queries.

Issue: 8
Location: const data = fetch(url).json();
Description: Missing await on fetch; .json() is being called on a Promise, causing a TypeError; do const res = await fetch(url); const data = await res.json().

Issue: 9
Location: if (!fs.existsSync(dir)) fs.mkdirSync(dir);
Description: Time-of-check-to-time-of-use race condition; a concurrent process may create dir between the checks; use fs.mkdir with { recursive: true } and handle EEXIST.

Issue: 10
Location: const avg = sum / count;
Description: Potential division by zero if count is 0, resulting in Infinity/NaN; guard or early-return when count === 0.

Issue: 11
Location: console.log(user.profile.email.toLowerCase());
Description: Possible null/undefined dereference if user, profile, or email is missing; add guards or use optional chaining (user?.profile?.email?.toLowerCase()).

Issue: 12
Location: const DB_PASSWORD = "P@ssw0rd123";
Description: Hardcoded credential in source code; move secrets to environment variables or a secrets manager.

Issue: 13
Location: for (let i = 0; i <= users.length; i++) { process(users[i]); }
Description: Off-by-one error; when i === users.length the code accesses users[i] as undefined. Use i < users.length instead.

Issue: 14
Location: const query = "SELECT * FROM users WHERE email = '" + email + "' AND pass = '" + pwd + "';";
Description: SQL injection risk by concatenating unsanitized input; use parameterized queries/prepared statements.

Issue: 15
Location: String city = user.getAddress().getCity().trim();
Description: Potential NullPointerException if any chained call returns null; add null checks or use Optional.

Issue: 16
Location: private static HashMap<String, Integer> counts = new HashMap<>();
Description: Non-thread-safe shared mutable state; use ConcurrentHashMap or synchronize access.

Issue: 17
Location: result = eval(request.args.get('expr'))
Description: Arbitrary code execution via eval on user input; replace with a safe parser or a whitelist-based evaluator.

Issue: 18
Location: def add_item(item, bucket=[]): bucket.append(item); return bucket
Description: Mutable default argument in Python; the same list instance is reused across calls, causing unexpected accumulation. Use None and initialize inside the function.

Issue: 19
Location: if (userInput == "yes") { proceed(); }
Description: In Java, == compares references, not string content. Use "yes".equals(userInput) or Objects.equals(userInput, "yes").

Issue: 20
Location: const token = Math.random().toString(36).slice(2);
Description: Insecure randomness for tokens; Math.random() is not cryptographically secure. Use a CSPRNG (e.g., crypto.randomBytes in Node.js).